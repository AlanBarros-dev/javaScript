
* do while (quase a mesma coisa que o while mas ele vai executar 1 vez sempre mesmo que
a condicao seja falsa como mostrado a baixo)

// definindo variavel como 0 
let velocidade = 0

        do{
            alert(`A velocidade do veiculo e: ${velocidade} km/h`)
            velocidade -= 20
        } while (velocidade > 0) // mesmo a condicao sendo falsa ele executa uma vez

        alert(`Velocidade final: ${velocidade} km/h`)


* for 
diferente do while e do while

o for precisa de 3 *condicoes sendo elas* : 
- Inicializacao; condicao; Finalizacao ex:

 criando uma variavel com 0 e repetindo ate 10

for (let indice = 0; indice <= 10; indice++) {
            alert(indice)
        }


_________________________________________________________________

                       - ARRAYS -

const arr = ["Killzone", "Mortal Kombat", "RE4", "Def Jam Fight", "Silent Hill", "God Of War", "GTA", "Twisted Metal", "Rule of Rose"]

*.push: adiciona um elemento no final do array.
ex: arr.push("Siren")

*.unshift: adiciona um elemento no comeco do array
ex: arr.unshift("The Warriors") 

*.pop(): remove elemento no final do array e o seleciona
ex:
const ultimoElemento = arr.pop()
        console.log(ultimoElemento)

*.shift: Remove o primeiro elemento do array e o seleciona 
ex:
const primeiroElemento = arr.shift()
        console.log(primeiroElemento)

*.includes: includes: verifica se o elemento existe no array e devolve como True ou False
ex:
const inclui = arr.includes("RE4")
        console.log(inclui)

*.indexOf: verifica qual o indice de um elemento do array
ex:
const indice = arr.indexOf("RE4")
        console.log(indice)

*.slice  copia uma parte do array e salva em um novo array
ex:
const jogosRockStar = arr.slice(7, 11)
console.log(jogosRockStar)

*.concat(): junta arrays e ainda pode adicionar novos elementos.

const sociedade = jogosRockStar.concat(outros, "crash")
        console.log(sociedade)

consultando oq tem dentro e as posicoes do array:
//iterar sobre os Elementos:
        for(let indice = 0; indice < nomeArray.length; indice++){
            const elemento = nomeArray[indice]
            console.log(`${elemento} se encontra na posicao ${indice}`)
        }

            MATRIZ (ARRAY BIDIMENSIONAL)

// adicionar no final da matriz
        matriz.push(["Nova Linha"])

// adicionar na linha especificada:
        matriz[0].push("Nova coluna")

 //iterando matriz

        for(let i = 0; i < matriz.length; i++){
            for(let j = 0; j < matriz[i].length; j++){
                const elemento = matriz[i][j]
                console.log("Posicao: ("+ i + "," + j + ") Valor :" + elemento)
            }
            
            console.log(matriz[i])
        }

_________________________________________________________________________________________________________

 * OBJETO *





criando metodos dentro do objeto:

1 crie um objeto:

	let pessoa = {
		nome: "Alex"
		idade: 20
	}

2. crie uma funcao dentro do objeto mas sem a palavra function apenas nomendo-a e colocando as suas especificacoes
ex:

	let pessoa = {
            nome: "Alan",
            idade: 20,
            dizerOla(){        
                console.log("Ola mundo")
            }
        }

3. Chamar a funcao, chame a funcao utilizando o objeto.nomeDaFuncao()
ex:
	pessoa.dizerOla()


4. Uso do *THIS* dentro do objeto:

para conseguir referenciar ou concatenar uma propriedade do proprio objeto dentro dele mesmo usamos o: this.propriedade
ex: this.nome / this.idade / this.endereco.

	let pessoa = {
            nome: "Alan",
            idade: 20,
            dizerOla(){
                console.log(`Ola Mundo meu nome e: ${this.nome}`)
            }
        } 




____________________________________________________________________________________________________________________________________


						* FUNCTION *



- funcao recursiva:
E aquela que se chama varias vezes dentro dela mesma exemplo:

 function dividir(num){
            console.log(num)
            if(num % 2 === 0){
                dividir(num / 2)
            }else{
                return num
            }
        }

        dividir(40)

ao usar funcao recursiva sempre defina quando ela vai parar pois se nao ela vira uma pilha infinita
